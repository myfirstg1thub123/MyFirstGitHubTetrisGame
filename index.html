<!doctype html>
<html lang="he">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris — Single File</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1628; --accent:#7dd3fc; --muted:#9aa4b2;
      --card:#0c1220; --glass: rgba(255,255,255,0.03);
      --accent-2:#7c3aed;
    }
    *{box-sizing:border-box}
    html,body{height:100%;}
    body{
      margin:0; font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background: linear-gradient(180deg,#041022 0%, #071427 60%); color:#e6eef8; display:flex; align-items:center; justify-content:center; padding:24px;
    }
    .wrap{display:grid; grid-template-columns: 320px 260px; gap:20px; align-items:start;}
    .board-card{background:var(--panel); padding:14px; border-radius:12px; box-shadow:0 8px 30px rgba(2,6,23,0.6);}
    h1{font-size:18px;margin:0 0 8px 0; color:var(--accent);}
    canvas{background: linear-gradient(180deg,#071026,#06121b); display:block; border-radius:8px; box-shadow: inset 0 2px 8px rgba(0,0,0,0.6);}

    .sidebar{background:var(--board,transparent); display:flex; flex-direction:column; gap:12px;}
    .panel{background:var(--card); padding:12px; border-radius:10px; min-height:64px}
    .stats{display:grid; grid-template-columns:1fr 1fr; gap:8px}
    .muted{color:var(--muted); font-size:13px}
    .big{font-size:20px; font-weight:700}
    .controls{font-size:13px; color:#dbeafe}
    .kbd{display:inline-block; padding:6px 8px; border-radius:6px; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.03); margin-right:6px}
    .footer{font-size:12px; color:var(--muted); text-align:center; margin-top:10px}
    .btn{display:inline-block;padding:8px 12px;border-radius:8px;background:linear-gradient(180deg,var(--accent),var(--accent-2));color:#04233a;font-weight:700;border:none;cursor:pointer}

    .next-canvas{width:120px;height:80px}

    @media(max-width:760px){
      .wrap{grid-template-columns:1fr;}
      .board-card{order:2}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board-card">
      <div style="display:flex;align-items:center;gap:12px;justify-content:space-between">
        <h1>TETRIS — הפרויקט שלי</h1>
        <div class="muted">קובץ בודד | עובד ב-GitHub Pages</div>
      </div>

      <canvas id="game" width="320" height="640"></canvas>
      <div style="display:flex;justify-content:space-between;margin-top:10px;align-items:center">
        <div class="muted">שורות שנמחקו: <span id="lines">0</span></div>
        <div class="muted">רמה: <span id="level">1</span></div>
        <div class="muted">מהירות: <span id="speed">0</span></div>
      </div>
      <div style="display:flex;gap:8px;margin-top:12px;justify-content:space-between">
        <button id="startBtn" class="btn">התחל/המשך</button>
        <button id="pauseBtn" class="btn" style="background:linear-gradient(180deg,#ef4444,#b91c1c);color:white">השהה</button>
        <button id="resetBtn" class="btn" style="background:linear-gradient(180deg,#94a3b8,#6b7280);color:white">איפוס</button>
      </div>
      <div class="footer">השתמש במקלדת: ← → להעברה, ↑/X לסיבוב, ↓ להורדה מהירה, Space להצנחה מהירה, C לאחיזה (hold)</div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <div class="muted">NEXT</div>
        <canvas id="next" class="next-canvas" width="120" height="80"></canvas>
      </div>

      <div class="panel">
        <div class="muted">SCORE</div>
        <div class="big" id="score">0</div>
        <div class="muted">אחוז התקדמות</div>
        <div style="height:8px;background:rgba(255,255,255,0.04);border-radius:6px;margin-top:8px;overflow:hidden">
          <div id="progress" style="height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent-2));"></div>
        </div>
      </div>

      <div class="panel stats">
        <div>
          <div class="muted">קוביה פעילה</div>
          <div id="activePiece" class="big">־</div>
        </div>
        <div>
          <div class="muted">אחוז מלא</div>
          <div id="filled" class="big">0%</div>
        </div>
      </div>

      <div class="panel controls">
        <div class="muted">פקודות</div>
        <div style="margin-top:8px">
          <span class="kbd">←</span> תזוז שמאלה<br>
          <span class="kbd">→</span> תזוז ימינה<br>
          <span class="kbd">↑ / X</span> סיבוב
          <br>
          <span class="kbd">↓</span> רדת סרגל
          <br>
          <span class="kbd">Space</span> נפילה מהירה
          <br>
          <span class="kbd">C</span> אחז (Hold)
        </div>
      </div>
    </div>
  </div>

  <script>
  // ------------ TETRIS: single-file implementation ------------
  // Grid is 10x20 standard. Canvas sized to display cells.

  const COLS = 10, ROWS = 20, BLOCK = 32;
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  canvas.width = COLS * BLOCK;
  canvas.height = ROWS * BLOCK;

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  // Colors for tetrominoes
  const COLORS = {
    I: '#06b6d4', O: '#facc15', T: '#a78bfa', S: '#34d399', Z: '#fb7185', J: '#60a5fa', L: '#fb923c'
  };

  // Tetromino definitions (rotations as arrays)
  const SHAPES = {
    I: [[[0,1],[1,1],[2,1],[3,1]], [[2,0],[2,1],[2,2],[2,3]]],
    O: [[[1,0],[2,0],[1,1],[2,1]]],
    T: [[[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[2,1],[1,2]], [[1,0],[0,1],[1,1],[1,2]]],
    S: [[[1,0],[2,0],[0,1],[1,1]], [[1,0],[1,1],[2,1],[2,2]]],
    Z: [[[0,0],[1,0],[1,1],[2,1]], [[2,0],[1,1],[2,1],[1,2]]],
    J: [[[0,0],[0,1],[1,1],[2,1]], [[1,0],[2,0],[1,1],[1,2]], [[0,1],[1,1],[2,1],[2,2]], [[1,0],[1,1],[0,2],[1,2]]],
    L: [[[2,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[2,2]], [[0,1],[1,1],[2,1],[0,2]], [[0,0],[1,0],[1,1],[1,2]]]
  };

  // Utilities
  function makeEmptyGrid(){
    const g = [];
    for(let r=0;r<ROWS;r++){
      g.push(new Array(COLS).fill(null));
    }
    return g;
  }

  function drawCell(x,y,color,ctxRef=ctx){
    const pad = 1;
    ctxRef.fillStyle = color;
    ctxRef.fillRect(x*BLOCK+pad, y*BLOCK+pad, BLOCK-2*pad, BLOCK-2*pad);
    // subtle highlight
    ctxRef.globalAlpha = 0.12;
    ctxRef.fillStyle = '#fff';
    ctxRef.fillRect(x*BLOCK+pad, y*BLOCK+pad, (BLOCK-2*pad), (BLOCK-2*pad)/2);
    ctxRef.globalAlpha = 1;
  }

  // Game state
  let grid = makeEmptyGrid();
  let score = 0, lines = 0, level = 1;
  let dropInterval = 800; // ms
  let lastDrop = 0; let running = false, paused = false, gameOver = false;

  // Active piece
  class Piece{
    constructor(type){
      this.type = type;
      this.rot = 0;
      this.shapes = SHAPES[type];
      this.blocks = this.shapes[this.rot];
      // spawn near top center
      this.x = Math.floor((COLS - 4)/2);
      this.y = -1; // let it fall into view
      this.color = COLORS[type];
      this.locked = false;
    }
    shape(){ return this.shapes[this.rot % this.shapes.length]; }
    rotate(dir=1){
      this.rot = (this.rot + dir + this.shapes.length) % this.shapes.length;
      this.blocks = this.shape();
    }
  }

  // Random bag generator
  function createBag(){
    const pieces = Object.keys(SHAPES);
    const bag = [];
    while(bag.length < pieces.length){
      const idx = Math.floor(Math.random()*pieces.length);
      if(!bag.includes(pieces[idx])) bag.push(pieces[idx]);
    }
    return bag;
  }

  let bag = createBag();
  let nextBag = createBag();
  let nextQueue = [];
  function refillQueue(){
    while(nextQueue.length < 5){
      if(bag.length===0){ bag = nextBag; nextBag = createBag(); }
      nextQueue.push(bag.shift());
    }
  }

  let current = null; let holdPiece = null; let holdLocked=false;

  function spawnPiece(){
    refillQueue();
    const t = nextQueue.shift();
    current = new Piece(t);
    // adjust spawn x for width tendencies
    current.x = 3;
    holdLocked = false;
    // if collision immediate -> game over
    if(collide(current, current.x, current.y)){
      gameOver = true; running = false;
    }
    renderNext();
  }

  // Collision
  function collide(piece, nx, ny){
    for(const b of piece.shape()){
      const x = nx + b[0];
      const y = ny + b[1];
      if(y < 0) continue;
      if(x < 0 || x >= COLS || y >= ROWS) return true;
      if(grid[y][x]) return true;
    }
    return false;
  }

  function lockPiece(){
    for(const b of current.shape()){
      const x = current.x + b[0];
      const y = current.y + b[1];
      if(y>=0) grid[y][x] = {color:current.color, type: current.type};
    }
    clearLines();
    spawnPiece();
  }

  function clearLines(){
    let cleared = 0;
    outer: for(let r=ROWS-1;r>=0;r--){
      for(let c=0;c<COLS;c++){
        if(!grid[r][c]) continue outer;
      }
      // this row is full
      grid.splice(r,1);
      grid.unshift(new Array(COLS).fill(null));
      cleared++;
      r++; // recheck same row index after splice
    }
    if(cleared>0){
      lines += cleared;
      // scoring: classic tetris scoring simplified
      const points = [0,40,100,300,1200];
      score += points[cleared] * level;
      // level up every 10 lines
      const newLevel = Math.floor(lines/10)+1;
      if(newLevel > level){ level = newLevel; dropInterval = Math.max(80, 800 - (level-1)*60); }
      document.getElementById('score').textContent = score;
      document.getElementById('lines').textContent = lines;
      document.getElementById('level').textContent = level;
      document.getElementById('speed').textContent = dropInterval + 'ms';
      updateProgress();
    }
  }

  function updateProgress(){
    const progress = Math.min(100, (lines % 10) * 10);
    document.getElementById('progress').style.width = progress + '%';
    document.getElementById('filled').textContent = Math.floor((grid.flat().filter(x=>x).length)/(ROWS*COLS)*100) + '%';
  }

  function move(dx){
    if(!current) return;
    if(!collide(current, current.x+dx, current.y)) current.x += dx;
  }

  function rotate(dir=1){
    if(!current) return;
    const origRot = current.rot;
    current.rotate(dir);
    // simple wall kicks
    const kicks = [0, -1, 1, -2, 2];
    for(const k of kicks){
      if(!collide(current, current.x+k, current.y)){
        current.x += k; return;
      }
    }
    // revert
    current.rot = origRot; current.blocks = current.shape();
  }

  function hardDrop(){
    if(!current) return;
    while(!collide(current, current.x, current.y+1)) current.y++;
    lockPiece();
  }

  function softDrop(){
    if(!current) return;
    if(!collide(current, current.x, current.y+1)) current.y++; else { lockPiece(); }
  }

  function hold(){
    if(holdLocked || !current) return;
    if(!holdPiece){ holdPiece = current.type; spawnPiece(); }
    else { const t = holdPiece; holdPiece = current.type; current = new Piece(t); }
    holdLocked = true;
    document.getElementById('activePiece').textContent = holdPiece || '-';
  }

  // Rendering
  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // draw background cells (subtle grid)
    ctx.globalAlpha = 0.04;
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) ctx.fillRect(c*BLOCK, r*BLOCK, BLOCK-1, BLOCK-1);
    ctx.globalAlpha = 1;

    // draw locked cells
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        const cell = grid[r][c];
        if(cell) drawCell(c,r,cell.color);
      }
    }

    // draw active piece
    if(current){
      for(const b of current.shape()){
        const x = current.x + b[0];
        const y = current.y + b[1];
        if(y>=0) drawCell(x,y,current.color);
      }
    }
  }

  function renderNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.save();
    nctx.translate(8,8);
    if(nextQueue[0]){
      const p = new Piece(nextQueue[0]);
      // draw centered
      for(const b of p.shape()){
        nctx.fillStyle = COLORS[p.type];
        nctx.fillRect(b[0]*16, b[1]*16, 14, 14);
      }
    }
    nctx.restore();
  }

  // Game loop
  function loop(ts){
    if(!running){ lastDrop = ts; requestAnimationFrame(loop); return; }
    if(paused) { requestAnimationFrame(loop); return; }
    if(!lastDrop) lastDrop = ts;
    const delta = ts - lastDrop;
    if(delta > dropInterval){
      lastDrop = ts;
      if(current && !collide(current, current.x, current.y+1)){
        current.y++;
      } else if(current){
        // lock and spawn
        lockPiece();
      }
    }
    drawGrid();
    if(gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0, canvas.height/2 - 40, canvas.width, 80);
      ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='24px sans-serif';
      ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
    }
    requestAnimationFrame(loop);
  }

  // Input handling
  document.addEventListener('keydown', e=>{
    if(!running) return;
    if(e.key === 'ArrowLeft'){ move(-1); }
    else if(e.key === 'ArrowRight'){ move(1); }
    else if(e.key === 'ArrowUp' || e.key.toLowerCase()==='x'){ rotate(1); }
    else if(e.key === 'ArrowDown'){ softDrop(); }
    else if(e.code === 'Space'){ hardDrop(); }
    else if(e.key.toLowerCase()==='c'){ hold(); }
  });

  // Buttons
  document.getElementById('startBtn').addEventListener('click', ()=>{
    if(gameOver){ resetGame(); }
    running = true; paused = false; requestAnimationFrame(loop);
  });
  document.getElementById('pauseBtn').addEventListener('click', ()=>{ paused = !paused; });
  document.getElementById('resetBtn').addEventListener('click', ()=>{ resetGame(); });

  function resetGame(){
    grid = makeEmptyGrid();
    bag = createBag(); nextBag = createBag(); nextQueue = [];
    refillQueue(); score = 0; lines = 0; level = 1; dropInterval = 800; gameOver=false; running=false; paused=false; holdPiece=null; holdLocked=false;
    document.getElementById('score').textContent = score; document.getElementById('lines').textContent = lines; document.getElementById('level').textContent = level; document.getElementById('activePiece').textContent = '-';
    spawnPiece(); drawGrid(); renderNext(); updateProgress();
  }

  // initialize
  refillQueue(); spawnPiece(); drawGrid(); renderNext(); updateProgress(); requestAnimationFrame(loop);
  
  // Helpful: allow clicking on canvas to start/pause
  canvas.addEventListener('click', ()=>{ if(!running){ running=true; requestAnimationFrame(loop); } else paused = !paused; });

  // Prevent arrow keys scrolling the page
  window.addEventListener('keydown', function(e) {
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].indexOf(e.code) > -1) e.preventDefault();
  }, false);
  </script>
</body>
</html>

